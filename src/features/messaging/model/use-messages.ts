import { useChatStore, MessageStatus, MessageType } from "@/entities/chat";
import type { FileInfo, Message } from "@/entities/chat";
import { useAuthStore } from "@/entities/auth";
import { getMatrixClientService } from "@/entities/matrix";
import type { PcryptoRoomInstance } from "@/entities/matrix/model/matrix-crypto";

export function useMessages() {
  const chatStore = useChatStore();
  const authStore = useAuthStore();

  /** Extract width/height from an image file */
  const getImageDimensions = (file: File): Promise<{ w: number; h: number }> => {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => {
        resolve({ w: img.naturalWidth, h: img.naturalHeight });
        URL.revokeObjectURL(img.src);
      };
      img.onerror = () => resolve({ w: 0, h: 0 });
      img.src = URL.createObjectURL(file);
    });
  };

  const sendMessage = async (content: string) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId || !content.trim()) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    const trimmed = content.trim();

    // Optimistic message
    const tempId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const message: Message = {
      id: tempId,
      roomId,
      senderId: authStore.address ?? "",
      content: trimmed,
      timestamp: Date.now(),
      status: MessageStatus.sending,
      type: MessageType.text,
    };
    chatStore.addMessage(roomId, message);

    try {
      // Check if room has encryption
      const roomCrypto = authStore.pcrypto?.rooms[roomId] as PcryptoRoomInstance | undefined;

      let serverEventId: string;
      if (roomCrypto?.canBeEncrypt()) {
        // Send encrypted
        const encrypted = await roomCrypto.encryptEvent(trimmed);
        serverEventId = await matrixService.sendEncryptedText(roomId, encrypted);
      } else {
        // Send plaintext
        serverEventId = await matrixService.sendText(roomId, trimmed);
      }

      // Replace temp ID with server event_id so read receipts can match
      if (serverEventId) chatStore.updateMessageId(roomId, tempId, serverEventId);
      chatStore.updateMessageStatus(roomId, serverEventId || tempId, MessageStatus.sent);
    } catch (e) {
      console.error("Failed to send message:", e);
      chatStore.updateMessageStatus(roomId, tempId, MessageStatus.failed);
    }
  };

  /** Send a file/image/video/audio message */
  const sendFile = async (file: File) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId || !file) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    // Determine message type from MIME
    let msgType = MessageType.file;
    if (file.type.startsWith("image/")) msgType = MessageType.image;
    else if (file.type.startsWith("video/")) msgType = MessageType.video;
    else if (file.type.startsWith("audio/")) msgType = MessageType.audio;

    // Optimistic message
    const tempId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const localBlobUrl = URL.createObjectURL(file);
    const message: Message = {
      id: tempId,
      roomId,
      senderId: authStore.address ?? "",
      content: file.name,
      timestamp: Date.now(),
      status: MessageStatus.sending,
      type: msgType,
      fileInfo: {
        name: file.name,
        type: file.type,
        size: file.size,
        url: localBlobUrl,
      },
    };
    chatStore.addMessage(roomId, message);

    try {
      const roomCrypto = authStore.pcrypto?.rooms[roomId] as PcryptoRoomInstance | undefined;

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const fileInfo: Record<string, any> = {
        name: file.name,
        type: file.type,
        size: file.size,
      };

      let fileToUpload: Blob = file;

      // Encrypt the file if room has encryption
      if (roomCrypto?.canBeEncrypt()) {
        const encrypted = await roomCrypto.encryptFile(file);
        fileInfo.secrets = encrypted.secrets;
        fileToUpload = encrypted.file;
      }

      // Upload to Matrix server
      const url = await matrixService.uploadContent(fileToUpload);
      fileInfo.url = url;

      // Send as m.file event with body = JSON of fileInfo
      // (This is the bastyon-chat format for all file types)
      const body = JSON.stringify(fileInfo);
      const serverEventId = await matrixService.sendEncryptedText(roomId, {
        body,
        msgtype: "m.file",
      });

      if (serverEventId) chatStore.updateMessageId(roomId, tempId, serverEventId);
      chatStore.updateMessageStatus(roomId, serverEventId || tempId, MessageStatus.sent);
    } catch (e) {
      console.error("Failed to send file:", e);
      chatStore.updateMessageStatus(roomId, tempId, MessageStatus.failed);
    }
  };

  /** Send an image message (m.image event — compatible with bastyon-chat) */
  const sendImage = async (file: File, options: { caption?: string; captionAbove?: boolean } = {}) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId || !file) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    const dimensions = await getImageDimensions(file);

    const tempId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const localBlobUrl = URL.createObjectURL(file);
    const message: Message = {
      id: tempId,
      roomId,
      senderId: authStore.address ?? "",
      content: options.caption || file.name,
      timestamp: Date.now(),
      status: MessageStatus.sending,
      type: MessageType.image,
      fileInfo: {
        name: file.name,
        type: file.type,
        size: file.size,
        url: localBlobUrl,
        w: dimensions.w,
        h: dimensions.h,
        caption: options.caption,
        captionAbove: options.captionAbove,
      },
    };
    chatStore.addMessage(roomId, message);

    try {
      const roomCrypto = authStore.pcrypto?.rooms[roomId] as PcryptoRoomInstance | undefined;

      let fileToUpload: Blob = file;
      let secrets: Record<string, unknown> | undefined;

      if (roomCrypto?.canBeEncrypt()) {
        const encrypted = await roomCrypto.encryptFile(file);
        secrets = encrypted.secrets;
        fileToUpload = encrypted.file;
      }

      const url = await matrixService.uploadContent(fileToUpload);

      const content: Record<string, unknown> = {
        body: options.caption || "Image",
        msgtype: "m.image",
        url,
        info: {
          w: dimensions.w,
          h: dimensions.h,
          mimetype: file.type,
          size: file.size,
          ...(secrets ? { secrets } : {}),
          ...(options.caption ? { caption: options.caption } : {}),
          ...(options.captionAbove != null ? { captionAbove: options.captionAbove } : {}),
        },
      };

      const serverEventId = await matrixService.sendEncryptedText(roomId, content);
      if (serverEventId) chatStore.updateMessageId(roomId, tempId, serverEventId);
      chatStore.updateMessageStatus(roomId, serverEventId || tempId, MessageStatus.sent);
    } catch (e) {
      console.error("Failed to send image:", e);
      chatStore.updateMessageStatus(roomId, tempId, MessageStatus.failed);
    }
  };

  /** Send an audio/voice message (m.audio event — compatible with bastyon-chat) */
  const sendAudio = async (file: File, options: { duration?: number; waveform?: number[] } = {}) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId || !file) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    const tempId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    // Create a local blob URL so VoiceMessage can play immediately (before upload completes)
    const localBlobUrl = URL.createObjectURL(file);
    const message: Message = {
      id: tempId,
      roomId,
      senderId: authStore.address ?? "",
      content: "Audio",
      timestamp: Date.now(),
      status: MessageStatus.sending,
      type: MessageType.audio,
      fileInfo: {
        name: file.name,
        type: file.type,
        size: file.size,
        url: localBlobUrl,
        duration: options.duration,
        waveform: options.waveform,
      },
    };
    chatStore.addMessage(roomId, message);

    try {
      const roomCrypto = authStore.pcrypto?.rooms[roomId] as PcryptoRoomInstance | undefined;

      let fileToUpload: Blob = file;
      let secrets: Record<string, unknown> | undefined;

      if (roomCrypto?.canBeEncrypt()) {
        const encrypted = await roomCrypto.encryptFile(file);
        secrets = encrypted.secrets;
        fileToUpload = encrypted.file;
      }

      const url = await matrixService.uploadContent(fileToUpload);

      // Matrix server rejects float values — ensure all numbers are integers.
      // Waveform: convert 0..1 floats to 0..1024 integers (Matrix spec range).
      const intWaveform = options.waveform?.map((v: number) => Math.round(v * 1024));

      const content: Record<string, unknown> = {
        body: "Audio",
        msgtype: "m.audio",
        url,
        info: {
          mimetype: file.type,
          size: Math.round(file.size),
          duration: options.duration ? Math.round(options.duration * 1000) : undefined,
          waveform: intWaveform,
          ...(secrets ? { secrets } : {}),
        },
      };

      const serverEventId = await matrixService.sendEncryptedText(roomId, content);
      if (serverEventId) chatStore.updateMessageId(roomId, tempId, serverEventId);
      chatStore.updateMessageStatus(roomId, serverEventId || tempId, MessageStatus.sent);
    } catch (e) {
      console.error("Failed to send audio:", e);
      chatStore.updateMessageStatus(roomId, tempId, MessageStatus.failed);
    }
  };

  const loadMessages = async (roomId: string) => {
    await chatStore.loadRoomMessages(roomId);
  };

  /** Set typing indicator */
  const setTyping = (isTyping: boolean) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId) return;
    const matrixService = getMatrixClientService();
    matrixService.setTyping(roomId, isTyping);
  };

  /** Toggle a reaction on a message.
   *  - One reaction per user: choosing a different emoji replaces the old one.
   *  - Clicking the same emoji removes it (toggle off).
   *  - Includes optimistic local update for instant feedback. */
  const toggleReaction = async (messageId: string, emoji: string) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    const roomMessages = chatStore.messages[roomId] ?? [];
    const msg = roomMessages.find(m => m.id === messageId);
    if (!msg) return;

    const myAddress = authStore.address ?? "";
    const existingSameEmoji = msg.reactions?.[emoji];

    // Find if user already reacted with ANY emoji on this message
    let existingOtherEmoji: string | undefined;
    let existingOtherEventId: string | undefined;
    if (msg.reactions) {
      for (const [key, data] of Object.entries(msg.reactions)) {
        if (key !== emoji && data.myEventId) {
          existingOtherEmoji = key;
          existingOtherEventId = data.myEventId;
          break;
        }
      }
    }

    const isServerEventId = (id?: string) => id?.startsWith("$");

    try {
      if (existingSameEmoji?.myEventId) {
        // Toggle off: user clicked the same emoji they already reacted with
        const reactionEventId = existingSameEmoji.myEventId;
        if (!isServerEventId(reactionEventId)) return; // still in-flight, ignore
        chatStore.optimisticRemoveReaction(roomId, messageId, emoji, myAddress);
        await matrixService.redactEvent(roomId, reactionEventId);
      } else {
        // Remove previous different-emoji reaction first (one reaction per user)
        if (existingOtherEmoji && isServerEventId(existingOtherEventId)) {
          const prevEventId = existingOtherEventId!;
          chatStore.optimisticRemoveReaction(roomId, messageId, existingOtherEmoji, myAddress);
          await matrixService.redactEvent(roomId, prevEventId);
        }
        // Send new reaction
        chatStore.optimisticAddReaction(roomId, messageId, emoji, myAddress);
        const realEventId = await matrixService.sendReaction(roomId, messageId, emoji);
        // Store the server-assigned event ID so redaction works later
        chatStore.setReactionEventId(roomId, messageId, emoji, realEventId);
      }
    } catch (e) {
      console.error("Failed to toggle reaction:", e);
      await chatStore.loadRoomMessages(roomId);
    }
  };

  /** Send message with reply context */
  const sendReply = async (content: string) => {
    const roomId = chatStore.activeRoomId;
    const replyTo = chatStore.replyingTo;
    if (!roomId || !content.trim() || !replyTo) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    const trimmed = content.trim();

    // Optimistic message
    const tempId = `msg_${Date.now()}_${Math.random().toString(36).slice(2, 9)}`;
    const message: Message = {
      id: tempId,
      roomId,
      senderId: authStore.address ?? "",
      content: trimmed,
      timestamp: Date.now(),
      status: MessageStatus.sending,
      type: MessageType.text,
      replyTo: {
        id: replyTo.id,
        senderId: replyTo.senderId,
        content: replyTo.content,
        type: replyTo.type,
      },
    };
    chatStore.addMessage(roomId, message);
    chatStore.replyingTo = null;

    try {
      const roomCrypto = authStore.pcrypto?.rooms[roomId] as PcryptoRoomInstance | undefined;

      const msgContent: Record<string, unknown> = {
        body: trimmed,
        msgtype: "m.text",
        "m.relates_to": {
          "m.in_reply_to": {
            event_id: replyTo.id,
          },
        },
      };

      let serverEventId: string;
      if (roomCrypto?.canBeEncrypt()) {
        const encrypted = await roomCrypto.encryptEvent(trimmed);
        // Merge reply relation into encrypted content
        const encContent = { ...encrypted, "m.relates_to": msgContent["m.relates_to"] };
        serverEventId = await matrixService.sendEncryptedText(roomId, encContent);
      } else {
        serverEventId = await matrixService.sendEncryptedText(roomId, msgContent);
      }

      if (serverEventId) chatStore.updateMessageId(roomId, tempId, serverEventId);
      chatStore.updateMessageStatus(roomId, serverEventId || tempId, MessageStatus.sent);
    } catch (e) {
      console.error("Failed to send reply:", e);
      chatStore.updateMessageStatus(roomId, tempId, MessageStatus.failed);
    }
  };

  /** Edit an existing message (Matrix m.replace relation) */
  const editMessage = async (messageId: string, newContent: string) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId || !newContent.trim()) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    const trimmed = newContent.trim();

    try {
      const roomCrypto = authStore.pcrypto?.rooms[roomId] as PcryptoRoomInstance | undefined;

      const editContent: Record<string, unknown> = {
        body: `* ${trimmed}`,
        msgtype: "m.text",
        "m.new_content": {
          body: trimmed,
          msgtype: "m.text",
        },
        "m.relates_to": {
          rel_type: "m.replace",
          event_id: messageId,
        },
      };

      if (roomCrypto?.canBeEncrypt()) {
        const encrypted = await roomCrypto.encryptEvent(trimmed);
        const encContent = {
          ...encrypted,
          "m.new_content": { body: trimmed, msgtype: "m.text" },
          "m.relates_to": editContent["m.relates_to"],
        };
        await matrixService.sendEncryptedText(roomId, encContent);
      } else {
        await matrixService.sendEncryptedText(roomId, editContent);
      }

      // Update local message
      chatStore.updateMessageContent(roomId, messageId, trimmed);
    } catch (e) {
      console.error("Failed to edit message:", e);
    }
  };

  /** Delete a message */
  const deleteMessage = async (messageId: string, forEveryone: boolean) => {
    const roomId = chatStore.activeRoomId;
    if (!roomId) return;

    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    try {
      if (forEveryone) {
        await matrixService.redactEvent(roomId, messageId, "deleted");
      }
      chatStore.removeMessage(roomId, messageId);
    } catch (e) {
      console.error("Failed to delete message:", e);
    }
  };

  /** Forward a message to another room — handles text, files, images, audio, video */
  const forwardMessage = async (message: Message, targetRoomId: string, withSenderInfo = true) => {
    const matrixService = getMatrixClientService();
    if (!matrixService.isReady()) return;

    try {
      const roomCrypto = authStore.pcrypto?.rooms[targetRoomId] as PcryptoRoomInstance | undefined;

      const originalForward = message.forwardedFrom;
      const forwardMeta: Record<string, unknown> | undefined = withSenderInfo
        ? {
            sender_id: originalForward?.senderId ?? message.senderId,
            sender_name: originalForward?.senderName
              ?? chatStore.getDisplayName(originalForward?.senderId ?? message.senderId),
          }
        : undefined;

      // Forward file/media messages by re-sending in the proper format
      if (message.fileInfo && message.type !== MessageType.text) {
        const fi = message.fileInfo;
        let content: Record<string, unknown>;

        if (message.type === MessageType.image) {
          content = {
            body: fi.caption || "Image",
            msgtype: "m.image",
            url: fi.url,
            info: {
              w: fi.w, h: fi.h,
              mimetype: fi.type, size: fi.size,
              ...(fi.secrets ? { secrets: fi.secrets } : {}),
            },
          };
        } else if (message.type === MessageType.audio) {
          content = {
            body: "Audio",
            msgtype: "m.audio",
            url: fi.url,
            info: {
              mimetype: fi.type, size: fi.size,
              duration: fi.duration ? fi.duration * 1000 : undefined,
              waveform: fi.waveform,
              ...(fi.secrets ? { secrets: fi.secrets } : {}),
            },
          };
        } else if (message.type === MessageType.video) {
          content = {
            body: fi.caption || "Video",
            msgtype: "m.video",
            url: fi.url,
            info: {
              w: fi.w, h: fi.h,
              mimetype: fi.type, size: fi.size,
              duration: fi.duration ? fi.duration * 1000 : undefined,
              ...(fi.secrets ? { secrets: fi.secrets } : {}),
            },
          };
        } else {
          // Generic file — send as m.file with JSON body (bastyon-chat compat)
          const fileBody: Record<string, unknown> = {
            name: fi.name, type: fi.type, size: fi.size, url: fi.url,
          };
          if (fi.secrets) fileBody.secrets = fi.secrets;
          if (fi.w) fileBody.w = fi.w;
          if (fi.h) fileBody.h = fi.h;
          content = { body: JSON.stringify(fileBody), msgtype: "m.file" };
        }

        if (forwardMeta) content["forwarded_from"] = forwardMeta;
        await matrixService.sendEncryptedText(targetRoomId, content);
        return;
      }

      // Forward text message
      const forwardContent: Record<string, unknown> = {
        body: message.content,
        msgtype: "m.text",
      };
      if (forwardMeta) forwardContent["forwarded_from"] = forwardMeta;

      if (roomCrypto?.canBeEncrypt()) {
        const encrypted = await roomCrypto.encryptEvent(message.content);
        const encContent = { ...encrypted };
        if (forwardMeta) {
          (encContent as Record<string, unknown>)["forwarded_from"] = forwardMeta;
        }
        await matrixService.sendEncryptedText(targetRoomId, encContent);
      } else {
        await matrixService.sendEncryptedText(targetRoomId, forwardContent);
      }
    } catch (e) {
      console.error("Failed to forward message:", e);
    }
  };

  return {
    deleteMessage,
    editMessage,
    forwardMessage,
    loadMessages,
    sendAudio,
    sendFile,
    sendImage,
    sendMessage,
    sendReply,
    setTyping,
    toggleReaction,
  };
}
